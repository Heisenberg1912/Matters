/**
 * Export Service for generating PDF and Excel reports
 * Uses jsPDF for PDFs and xlsx for Excel files
 */

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';
import type { Report } from '@/store/types';

// Extend jsPDF type to include autoTable
declare module 'jspdf' {
  interface jsPDF {
    lastAutoTable: { finalY: number };
  }
}

// Color palette matching the app theme
const COLORS = {
  primary: '#cfe0ad',
  primaryDark: '#a3b87e',
  text: '#333333',
  textLight: '#666666',
  border: '#e0e0e0',
  background: '#f5f5f5',
};

// Helper to format currency
function formatCurrency(amount: number, currency = 'INR'): string {
  const symbol = currency === 'USD' ? '$' : '\u20B9';
  return `${symbol}${amount.toLocaleString('en-IN', { maximumFractionDigits: 0 })}`;
}

// Helper to format date
function formatDate(date?: string | Date): string {
  if (!date) return 'N/A';
  return new Date(date).toLocaleDateString('en-IN', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
}

/**
 * Export report as PDF
 */
export async function exportToPDF(report: Report, projectName?: string): Promise<void> {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  let yPos = 20;

  // Header
  doc.setFillColor(207, 224, 173); // Primary green
  doc.rect(0, 0, pageWidth, 40, 'F');

  doc.setTextColor(51, 51, 51);
  doc.setFontSize(24);
  doc.setFont('helvetica', 'bold');
  doc.text(report.name, 14, 25);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Generated: ${formatDate(report.generatedDate)}`, 14, 35);
  if (projectName) {
    doc.text(`Project: ${projectName}`, pageWidth / 2, 35);
  }

  yPos = 55;

  // Content based on report type
  switch (report.type) {
    case 'budget':
      yPos = renderBudgetPDF(doc, report.data, yPos);
      break;
    case 'progress':
      yPos = renderProgressPDF(doc, report.data, yPos);
      break;
    case 'inventory':
      yPos = renderInventoryPDF(doc, report.data, yPos);
      break;
    case 'contractor':
      yPos = renderContractorPDF(doc, report.data, yPos);
      break;
    case 'weekly':
      yPos = renderWeeklyPDF(doc, report.data, yPos);
      break;
    default:
      doc.setFontSize(12);
      doc.text('Report data:', 14, yPos);
      yPos += 10;
      const jsonStr = JSON.stringify(report.data, null, 2);
      const lines = doc.splitTextToSize(jsonStr, pageWidth - 28);
      doc.setFontSize(8);
      doc.text(lines, 14, yPos);
  }

  // Footer
  const pageCount = doc.internal.pages.length - 1;
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(128, 128, 128);
    doc.text(
      `Page ${i} of ${pageCount} | Generated by Matters`,
      pageWidth / 2,
      doc.internal.pageSize.getHeight() - 10,
      { align: 'center' }
    );
  }

  // Save
  const filename = `${report.name.replace(/\s+/g, '_')}_${report.generatedDate}.pdf`;
  doc.save(filename);
}

function renderBudgetPDF(doc: jsPDF, data: Record<string, unknown>, startY: number): number {
  let yPos = startY;
  const pageWidth = doc.internal.pageSize.getWidth();

  // Overview section
  const overview = data.overview as Record<string, number> | undefined;
  if (overview) {
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(51, 51, 51);
    doc.text('Budget Overview', 14, yPos);
    yPos += 10;

    const overviewData = [
      ['Total Budget', formatCurrency(overview.totalBudget || 0)],
      ['Total Spent', formatCurrency(overview.totalSpent || 0)],
      ['Total Paid', formatCurrency(overview.totalPaid || 0)],
      ['Pending', formatCurrency(overview.pending || 0)],
      ['Utilization', `${overview.utilization || 0}%`],
      ['Total Bills', String(overview.billCount || 0)],
    ];

    autoTable(doc, {
      startY: yPos,
      head: [['Metric', 'Value']],
      body: overviewData,
      theme: 'grid',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
      styles: { fontSize: 10 },
      columnStyles: { 0: { fontStyle: 'bold' }, 1: { halign: 'right' } },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  // By Type section
  const byType = data.byType as Array<{ _id: string; total: number; count: number }> | undefined;
  if (byType && byType.length > 0) {
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Spending by Type', 14, yPos);
    yPos += 8;

    const typeData = byType.map((t) => [
      t._id || 'Other',
      formatCurrency(t.total || 0),
      String(t.count || 0),
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Type', 'Total Amount', 'Bill Count']],
      body: typeData,
      theme: 'striped',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
      styles: { fontSize: 9 },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  // By Category section
  const byCategory = data.byCategory as Array<{ _id: string; total: number; count: number }> | undefined;
  if (byCategory && byCategory.length > 0) {
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Spending by Category', 14, yPos);
    yPos += 8;

    const categoryData = byCategory.slice(0, 10).map((c) => [
      c._id || 'Other',
      formatCurrency(c.total || 0),
      String(c.count || 0),
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Category', 'Total Amount', 'Bill Count']],
      body: categoryData,
      theme: 'striped',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
      styles: { fontSize: 9 },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  return yPos;
}

function renderProgressPDF(doc: jsPDF, data: Record<string, unknown>, startY: number): number {
  let yPos = startY;

  // Summary
  const summary = data.summary as Record<string, number> | undefined;
  if (summary) {
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text('Progress Summary', 14, yPos);
    yPos += 10;

    const summaryData = [
      ['Total Stages', String(summary.totalStages || 0)],
      ['Completed', String(summary.completedStages || 0)],
      ['In Progress', String(summary.inProgressStages || 0)],
      ['Average Progress', `${summary.averageProgress || 0}%`],
    ];

    autoTable(doc, {
      startY: yPos,
      head: [['Metric', 'Value']],
      body: summaryData,
      theme: 'grid',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
      columnStyles: { 0: { fontStyle: 'bold' }, 1: { halign: 'right' } },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  // Stages
  const stages = data.stages as Array<{ name: string; status: string; progress: number }> | undefined;
  if (stages && stages.length > 0) {
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Stages Detail', 14, yPos);
    yPos += 8;

    const stagesData = stages.map((s) => [
      s.name || 'Unnamed',
      s.status || 'pending',
      `${s.progress || 0}%`,
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Stage', 'Status', 'Progress']],
      body: stagesData,
      theme: 'striped',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  return yPos;
}

function renderInventoryPDF(doc: jsPDF, data: Record<string, unknown>, startY: number): number {
  let yPos = startY;

  // Overview
  const overview = data.overview as Record<string, number> | undefined;
  if (overview) {
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text('Inventory Overview', 14, yPos);
    yPos += 10;

    const overviewData = [
      ['Total Items', String(overview.totalItems || 0)],
      ['Total Value', formatCurrency(overview.totalValue || 0)],
      ['Low Stock Items', String(overview.lowStockCount || 0)],
      ['Out of Stock', String(overview.outOfStockCount || 0)],
    ];

    autoTable(doc, {
      startY: yPos,
      head: [['Metric', 'Value']],
      body: overviewData,
      theme: 'grid',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
      columnStyles: { 0: { fontStyle: 'bold' }, 1: { halign: 'right' } },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  // By Category
  const byCategory = data.byCategory as Array<{ _id: string; count: number; value: number }> | undefined;
  if (byCategory && byCategory.length > 0) {
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Inventory by Category', 14, yPos);
    yPos += 8;

    const categoryData = byCategory.map((c) => [
      c._id || 'Other',
      String(c.count || 0),
      formatCurrency(c.value || 0),
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Category', 'Item Count', 'Total Value']],
      body: categoryData,
      theme: 'striped',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  // Low Stock Items
  const lowStock = data.lowStockItems as Array<{ name: string; quantity: { current: number; minimum: number } }> | undefined;
  if (lowStock && lowStock.length > 0) {
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(220, 53, 69); // Red for warning
    doc.text('Low Stock Alert', 14, yPos);
    doc.setTextColor(51, 51, 51);
    yPos += 8;

    const lowStockData = lowStock.map((item) => [
      item.name || 'Unknown',
      String(item.quantity?.current || 0),
      String(item.quantity?.minimum || 0),
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Item', 'Current Qty', 'Min Qty']],
      body: lowStockData,
      theme: 'striped',
      headStyles: { fillColor: [220, 53, 69], textColor: [255, 255, 255] },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  return yPos;
}

function renderContractorPDF(doc: jsPDF, data: Record<string, unknown>, startY: number): number {
  let yPos = startY;

  const contractors = data.contractors as Array<{ name: string; totalPaid: number; billCount: number }> | undefined;
  if (contractors && contractors.length > 0) {
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text('Contractor Payments', 14, yPos);
    yPos += 10;

    const contractorData = contractors.map((c) => [
      c.name || 'Unknown',
      formatCurrency(c.totalPaid || 0),
      String(c.billCount || 0),
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Contractor', 'Total Paid', 'Bill Count']],
      body: contractorData,
      theme: 'striped',
      headStyles: { fillColor: [207, 224, 173], textColor: [51, 51, 51] },
    });

    yPos = doc.lastAutoTable.finalY + 15;
  }

  return yPos;
}

function renderWeeklyPDF(doc: jsPDF, data: Record<string, unknown>, startY: number): number {
  let yPos = startY;

  // Budget summary
  if (data.budget) {
    yPos = renderBudgetPDF(doc, data.budget as Record<string, unknown>, yPos);
  }

  // Add page break if needed
  if (yPos > doc.internal.pageSize.getHeight() - 50) {
    doc.addPage();
    yPos = 20;
  }

  // Progress summary
  if (data.stages) {
    const stages = data.stages as Array<{ name: string; status: string; progress: number }>;
    const completed = stages.filter((s) => s.status === 'completed').length;
    const progressData = {
      summary: {
        totalStages: stages.length,
        completedStages: completed,
        inProgressStages: stages.filter((s) => s.status === 'in_progress').length,
        averageProgress: stages.length > 0 ? Math.round(stages.reduce((a, s) => a + s.progress, 0) / stages.length) : 0,
      },
      stages,
    };
    yPos = renderProgressPDF(doc, progressData, yPos);
  }

  // Inventory summary
  if (data.inventory) {
    if (yPos > doc.internal.pageSize.getHeight() - 50) {
      doc.addPage();
      yPos = 20;
    }
    yPos = renderInventoryPDF(doc, data.inventory as Record<string, unknown>, yPos);
  }

  return yPos;
}

/**
 * Export report as Excel
 */
export function exportToExcel(report: Report, projectName?: string): void {
  const wb = XLSX.utils.book_new();

  // Add metadata sheet
  const metaData = [
    ['Report Name', report.name],
    ['Report Type', report.type],
    ['Generated Date', formatDate(report.generatedDate)],
    ['Project', projectName || 'N/A'],
    ['', ''],
    ['Generated by', 'Matters - Construction Project Management'],
  ];
  const metaSheet = XLSX.utils.aoa_to_sheet(metaData);
  XLSX.utils.book_append_sheet(wb, metaSheet, 'Info');

  // Add data sheets based on report type
  switch (report.type) {
    case 'budget':
      addBudgetSheets(wb, report.data);
      break;
    case 'progress':
      addProgressSheets(wb, report.data);
      break;
    case 'inventory':
      addInventorySheets(wb, report.data);
      break;
    case 'contractor':
      addContractorSheets(wb, report.data);
      break;
    case 'weekly':
      addWeeklySheets(wb, report.data);
      break;
    default:
      // Generic data dump
      const jsonSheet = XLSX.utils.json_to_sheet([report.data]);
      XLSX.utils.book_append_sheet(wb, jsonSheet, 'Data');
  }

  // Save
  const filename = `${report.name.replace(/\s+/g, '_')}_${report.generatedDate}.xlsx`;
  XLSX.writeFile(wb, filename);
}

function addBudgetSheets(wb: XLSX.WorkBook, data: Record<string, unknown>): void {
  // Overview sheet
  const overview = data.overview as Record<string, number> | undefined;
  if (overview) {
    const overviewData = [
      ['Metric', 'Value'],
      ['Total Budget', overview.totalBudget || 0],
      ['Total Spent', overview.totalSpent || 0],
      ['Total Paid', overview.totalPaid || 0],
      ['Pending', overview.pending || 0],
      ['Utilization (%)', overview.utilization || 0],
      ['Total Bills', overview.billCount || 0],
    ];
    const sheet = XLSX.utils.aoa_to_sheet(overviewData);
    XLSX.utils.book_append_sheet(wb, sheet, 'Overview');
  }

  // By Type
  const byType = data.byType as Array<{ _id: string; total: number; count: number }> | undefined;
  if (byType && byType.length > 0) {
    const typeData = [['Type', 'Total Amount', 'Bill Count']];
    byType.forEach((t) => {
      typeData.push([t._id || 'Other', String(t.total || 0), String(t.count || 0)]);
    });
    const sheet = XLSX.utils.aoa_to_sheet(typeData);
    XLSX.utils.book_append_sheet(wb, sheet, 'By Type');
  }

  // By Category
  const byCategory = data.byCategory as Array<{ _id: string; total: number; count: number }> | undefined;
  if (byCategory && byCategory.length > 0) {
    const categoryData = [['Category', 'Total Amount', 'Bill Count']];
    byCategory.forEach((c) => {
      categoryData.push([c._id || 'Other', String(c.total || 0), String(c.count || 0)]);
    });
    const sheet = XLSX.utils.aoa_to_sheet(categoryData);
    XLSX.utils.book_append_sheet(wb, sheet, 'By Category');
  }

  // Monthly Trend
  const monthlyTrend = data.monthlyTrend as Array<{ month: string; total: number; count: number }> | undefined;
  if (monthlyTrend && monthlyTrend.length > 0) {
    const trendData = [['Month', 'Total Amount', 'Bill Count']];
    monthlyTrend.forEach((m) => {
      trendData.push([m.month || '', String(m.total || 0), String(m.count || 0)]);
    });
    const sheet = XLSX.utils.aoa_to_sheet(trendData);
    XLSX.utils.book_append_sheet(wb, sheet, 'Monthly Trend');
  }
}

function addProgressSheets(wb: XLSX.WorkBook, data: Record<string, unknown>): void {
  // Summary
  const summary = data.summary as Record<string, number> | undefined;
  if (summary) {
    const summaryData = [
      ['Metric', 'Value'],
      ['Total Stages', summary.totalStages || 0],
      ['Completed Stages', summary.completedStages || 0],
      ['In Progress Stages', summary.inProgressStages || 0],
      ['Average Progress (%)', summary.averageProgress || 0],
    ];
    const sheet = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(wb, sheet, 'Summary');
  }

  // Stages
  const stages = data.stages as Array<{ name: string; status: string; progress: number; startDate?: string; endDate?: string }> | undefined;
  if (stages && stages.length > 0) {
    const stagesData = [['Stage Name', 'Status', 'Progress (%)', 'Start Date', 'End Date']];
    stages.forEach((s) => {
      stagesData.push([
        s.name || 'Unnamed',
        s.status || 'pending',
        String(s.progress || 0),
        formatDate(s.startDate),
        formatDate(s.endDate),
      ]);
    });
    const sheet = XLSX.utils.aoa_to_sheet(stagesData);
    XLSX.utils.book_append_sheet(wb, sheet, 'Stages');
  }
}

function addInventorySheets(wb: XLSX.WorkBook, data: Record<string, unknown>): void {
  // Overview
  const overview = data.overview as Record<string, number> | undefined;
  if (overview) {
    const overviewData = [
      ['Metric', 'Value'],
      ['Total Items', overview.totalItems || 0],
      ['Total Value', overview.totalValue || 0],
      ['Low Stock Items', overview.lowStockCount || 0],
      ['Out of Stock', overview.outOfStockCount || 0],
    ];
    const sheet = XLSX.utils.aoa_to_sheet(overviewData);
    XLSX.utils.book_append_sheet(wb, sheet, 'Overview');
  }

  // By Category
  const byCategory = data.byCategory as Array<{ _id: string; count: number; value: number }> | undefined;
  if (byCategory && byCategory.length > 0) {
    const categoryData = [['Category', 'Item Count', 'Total Value']];
    byCategory.forEach((c) => {
      categoryData.push([c._id || 'Other', String(c.count || 0), String(c.value || 0)]);
    });
    const sheet = XLSX.utils.aoa_to_sheet(categoryData);
    XLSX.utils.book_append_sheet(wb, sheet, 'By Category');
  }

  // Low Stock
  const lowStock = data.lowStockItems as Array<{ name: string; category?: string; quantity: { current: number; minimum: number } }> | undefined;
  if (lowStock && lowStock.length > 0) {
    const lowStockData = [['Item Name', 'Category', 'Current Qty', 'Min Qty']];
    lowStock.forEach((item) => {
      lowStockData.push([
        item.name || 'Unknown',
        item.category || 'N/A',
        String(item.quantity?.current || 0),
        String(item.quantity?.minimum || 0),
      ]);
    });
    const sheet = XLSX.utils.aoa_to_sheet(lowStockData);
    XLSX.utils.book_append_sheet(wb, sheet, 'Low Stock Alert');
  }
}

function addContractorSheets(wb: XLSX.WorkBook, data: Record<string, unknown>): void {
  const contractors = data.contractors as Array<{ name: string; totalPaid: number; billCount: number }> | undefined;
  if (contractors && contractors.length > 0) {
    const contractorData = [['Contractor Name', 'Total Paid', 'Bill Count']];
    contractors.forEach((c) => {
      contractorData.push([c.name || 'Unknown', String(c.totalPaid || 0), String(c.billCount || 0)]);
    });
    const sheet = XLSX.utils.aoa_to_sheet(contractorData);
    XLSX.utils.book_append_sheet(wb, sheet, 'Contractors');
  }
}

function addWeeklySheets(wb: XLSX.WorkBook, data: Record<string, unknown>): void {
  if (data.budget) {
    addBudgetSheets(wb, data.budget as Record<string, unknown>);
  }
  if (data.stages) {
    const progressData = { stages: data.stages, summary: {} };
    addProgressSheets(wb, progressData);
  }
  if (data.inventory) {
    addInventorySheets(wb, data.inventory as Record<string, unknown>);
  }
}

/**
 * Export service object for easy importing
 */
export const exportService = {
  exportToPDF,
  exportToExcel,
};

export default exportService;
